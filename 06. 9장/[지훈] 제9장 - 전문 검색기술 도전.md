# 09. 전문 검색기술 도전

검색 기술을 배우는 이유
검색엔진은 내부에 다양한 알고리즘이 응용되어 있다.
검색엔진의 원리를 알고 있으면 요구사항을 만족하도록 직접 인덱스를 만들어서 이 문제를 회피 할 수 있다.
즉, 대규모 데이터를 다 떠안지 못하게 된 데이터베이스의 한계를 검색시스템으로 돌파할 수 있다.
대규모 데이터를 상대할 때 검색엔진의 노하우를 알아두면 문제 해결에 도움이 된다.
이런 관점에서 강의 내용을 살펴보자

# 24. 전문 검색기술의 응용범위

이번 장은 하테나에서 실제로 운용하고 있는 검색엔진에 대한 개요부터 시작해서
검색엔진을 만들때 중요한 요소 중 하나인 `역 인덱스` 에 대해 설명한다.

이번 장은 `역 인덱스` 를 기반으로 검색엔진의 기본구조를 이해하는 것을 목표로 한다.

# 25. 검색 시스템의 아키텍처

## 검색 시스템이 완성되기까지

‘전문 검색’을 구현하기 위해서는 아래 절차를 거쳐야 한다.

- 크롤링

  처음에 검색할 대상 문서를 가져와야한다.
  이를 일반적으로 `크롤링`이라고 한다.
  대상 문서가 웹에 있다면 웹 크롤러를 만들어서 대량 문서를 가져오는 작업이 필요하다.

- 저장

  그 다음에는 가져온 문서를 어떻게 `저장`할 것인가 라는 문제가 있다.
  예를 들어, DB 하나에 데이터를 넣는다면 데이터 유실 시 복원이 불가능함 → 분산 DB에 저장해야함

- 인덱싱

  그리고 가져온 문서로부터 `인덱스`를 구축한다.

- 검색
- 스코어링

  검색에서는 검색 쿼리를 포함하는 문서가 검색결과로 반환되는데,
  그 순서를 지정하는 것을`스코어링` 이라고 한다.

- 결과표시

  스코어링 후 결과를 표시한다.


이번 장에서는 `인덱싱` 과 `검색` 에 대해서 집중적으로 설명한다.

## 다양한 검색엔진

검색엔진은 위의 절차 중 `인덱싱`과 `검색` 을 실행한다.

이 검색엔진은 과거부터 많이 개발되어 왔는데
아래 오픈소스가 대표적이다.

- grep
- Namazu
- Hyper Estraier
- Apache Lucene
- Shunsaku
- Senna
- Sedue
- Lux

![image.png](attachment:b365049c-c5e6-4745-8bc6-7c7e763e27a7:image.png)

## 전문 검색의 종류

전문 검색의 아키텍처에는 종류가 꽤나 많은데,
책에서 3가지의 유형을 소개한다.

- grep형
- Suffix형
- 역 인덱스형

### grep형

`grep형`은 검색 대상 문서를 처음부터 전부 읽어가는, 말하자면 가장 단순한 구조이다.
전부 읽어가면 어딘가에서는 해당 문서가 발견되기 때문이다.

- 속도
  - 검색 대상인 텍스트 길이를 `m`, 검색어의 길이를 `n`이라고 했을 때 이는 `O(mn)`만큼 걸림
  - 검색 처리로는 상당히 느린편이다.
- 장점
  - 즉시성이 좋다. ( 문서가 갱신되더라도 바로 검색할 수 있다. )
  - 대상 문서를 처음부터 전부 읽어가기 때문에 검색누락이 없다.
  - 병렬화하기가 매우 간단하다.
    - ex) 매우 긴 문서를 검색하고자 할 때, 분할해서 병렬로 검색할 수 있다.

### Suffix형

`Suffix형`은 검색 대상 전문을 검색 가능한 형태로 가지고 있다.
데이터 구조로는 `Trie`, `Suffix Array`  `Suffix Tree` 등이 있다.

`Suffix형`은 문서를 전부 메모리에 올릴 수 있는 형태로 만들고 이를 통해 빠르게 검색한다.
이 또한 데이터가 커지며 이론적으로는 검색이 가능해진다는 것을 알지만
실제 이 구조를 가진 엔진은 좀처럼 구현하기 힘들다.

### 역 인덱스형

`역 인덱스형` 은 단어(term)와 문서를 연관짓는 형식이다. ( 뒤에서 설명 )

- 단점
  - 역 인덱스를 문서와는 별개로 만들어야 한다.(검색하기 전에 인덱스를 전처리로 만들어야함)

    → grep과는 다르게 즉시성이 좋지 못함

  - 구현방법에 따라서는 검색누락이 생길 수도 있다.
    - 예시

      ## 🎯 예시: **형태소 분석기 미사용 또는 잘못 설정된 경우**

      ### 🔍 상황

      - 문서: `"나는 사과를 좋아해"`
      - 검색어: `"사과"`

      ### 💥 문제 발생 케이스

      검색엔진 설정에서 **형태소 분석기 없이 단순 스페이스 분리(tokenizer)** 만 사용한 경우:

        ```
        plaintext
        [색인된 토큰]
        "나는", "사과를", "좋아해"
        
        ```

      이 경우, "사과"는 포함되지 않음 → **사용자가 "사과"로 검색해도 이 문서는 안 나옴**
        
      ---

      ## 🧠 왜 이런 일이 생기냐면?

      - 한국어는 **공백으로 단어를 정확히 나누기 어려운 언어**예요.
      - "사과를"이라는 토큰 안에 "사과"가 있지만, 역 인덱스는 **완전 일치 기반**으로 작동하기 때문에 `"사과"`라는 토큰이 없으면 검색 누락됨.

        ---

      ## ✅ 해결 방법

      1. *형태소 분석기(Nori, MeCab 등)**를 사용해서 문장을 분석:

          ```
          plaintext
          "나는 사과를 좋아해" → ["나", "사과", "좋아"]
          
          ```

      2. 이걸로 인덱싱하면 `"사과"`라는 토큰이 명확히 들어가므로 검색어 `"사과"`로도 문서가 검색됨
- 장점
  - 인덱스를 압축함으로써 컴팩트하게 가져갈 수 있고, 대규모화하기도 쉽다.
    

# 26. 검색엔진의 내부구조

## 역 인덱스의 구조

역 인덱스의 내부구조는 크게 `Dictionary`와 `Postings`라는 두 파트로 나뉜다.

검색하고자하는 대상 문서들이 아래와 같이 있을 때,

![image.png](attachment:19795877-cfe0-4368-be9b-b8fd051aa2cf:image.png)

문서들을 역인덱스화 하면 아래와 같아진다.

![image.png](attachment:2060f323-2170-4e01-b31d-6653f8a78ab1:image.png)

- `Dictionary`
  - 여기서 “하테나”, “시나몬” 같은 단어를 `term` 이라고 하고,
    이 `term` 의 집합을 `Dictionary` 라고 한다.
- `Postings`
  - 각 `term` 을 포함하고 있는 문서는 몇 번인지를 나타내는게 우측의 배열이다.
    이것을 `Postings` 라고 한다.

이것이 역 인덱스다.

- 역 인덱스 = `Dictionary` + `Postings`
- ex) '교토'로 검색하면 3번만 포함되어 있다거나,
  인덱스를 보면 바로 어떤 문서에 어떤 단어가 포함되어 있는지 알 수 있다.

→ `term` 은 문서 내의 단어이고 문서를 검색 할 수 있는 단위이다.
역 인덱스는 `term` 을 포함하는 문서를 즉시 발견 할 수 있는 구조로 되어있다.

## Dictionary 만드는 법

Dictionary를 만들 때, 어떤 기준으로  `term`을 선택하는지 결정해야 한다는 문제가 있다.

이 책에서는 아래 두가지 방법을 소개한다.

- 단어를 term으로 선택하는 방법
- n-gram을 term으로 선택하는 방법

### 단어를 term으로 선택하는 방법

1. 사전 + AC법을 이용하는 방법

사전을 활용하면 사전이 곧 검색 시스템의 단어공간이 된다. 
→ 즉, 사전에 들어 있는 단어만 검색할 수 있다. 

- ex) 하테나 키워드는 27만 정도의 단어가 있는데,
                                                              이것으로 27만 단어로 검색이 가능한 엔진이 된다.

1. 형태소 분석을 이용하는 방법

형태소를 단어로 간주해서 term으로 한다.
여기에는 다양한 `형태소 분석기`가 사용된다.

`형태소 분석기`

- `유형파악과 분리`에 의해 문장을 형태소로 분할한다.
  - 예를 들어 어떤 텍스트를 명사, 부사 등의 품사로 분해하는 것을 `유형파악과 분리`라고 하고
  - 이 원리에 따라 세세하게 나눈 각 단어를 `형태소`라고 한다.
- 문장을 형태소로 나눠서 그 품사를 추정한다.
  - 품사를 어떻게 추정하지?
    - 내부에 별도의 형태소 분석 사전을 가지고 있어서
      그 사전을 보고 품사를 추정한다.
  - 형태소 분석기의 종류에 따라서는 사전에 없는 단어도 예상 할 수 있다.
  - 기계학습을 통해 단어의 배열을 학습해서 품사를 추정 할 수도 있다.
    - ex) ‘명사’ 다음에는 ‘조사’가 온다거나~,
      ‘조사’와 ‘동사’ 사이에 포함되어 있는 것은 ‘명사’일 수 있다 거나~
  - 형태소 분석기의 사전은 직접 커스터마이징 할 수도 있다.

### 검색 누락

사전으로 나누던 형태로소 나누던간에 결국 검색누락이 발생할 수 있다.

예를 들어 

`Gears of War`이라는 게임 타이틀이 있다.

- `Gears 발매일`이라고 `and` 검색 →  정확하게 `Gears of War`발매일이 검색됨
- `Gear 발매일`이라고 검색 →  `Metal Gear`라는 게임의 발매일이 검색됨

 

`Gears` 에는 `Gear` 가 포함되어 있다.
그럼 `Gears of War` 에 대한 것도 검색되어야 할 것 같다.

하지만!
`Gears`라는 단어는 역 인덱스로 `Gears of War` 에 이어져 있지만
`Gear`라는 단어가 사전에 없기 때문에
`Gear` 라는 키워드에서는 `Gears of War` 가 검색되지 않았다.

이 결과는 해당 검색엔진의 설계나 사상에 따라 맞는 결과일 수도 아닐 수도 있다.

### n-gram을 term으로 선택하는 방법

`n-gram`이란 텍스트를 n자씩 잘라낸 것을 의미한다.

- ex) `abracadabra`의 3-gram → `abr`, `bra`, `rac`...
- ex) "`사과를 좋아해`”의 2-gram → ["사과", "과를", "를 ", " 좋", "좋아", "아해"]

이렇게 `n-gram` 으로 잘라낸 단위를 `term`으로 다루는 방법이 있다.

![image.png](attachment:0132d9f9-9f09-4af3-a6b6-a75a8d2080b0:image.png)

### 쿼리도 동일한 규칙으로 분할하기

`n-gram`을 `Dictionary` 로 사용할 경우, 쿼리도 동일한 규칙으로 분할한다.

ex) 사용자가 '하테나'로 검색할 경우

- 쿼리를 '하테', '테나'로 분할하여 검색을 수행한다.
- 이 두가지 쿼리로 역인덱스를 조회하면 두개의 `Postings` 가 얻어진다.
- 그 결과 양쪽에 포함된 공통문서 번호가 ‘하테나’를 포함하는 문서이다. ( `교집합` )

### n-gram 분할 문제와 필터링

n-gram으로 term을 결정할 경우, 잘게 쪼개진 term 때문에 정확도가 떨어질 수 있다.

(책의 예시는 무슨 말인지 모르겠어서 새로 찾아서 적음)

예를 들어

- 예시 문장 : "엘라스틱서치는 강력한 검색엔진입니다."
- 2-gram 인덱싱 :  
  ["엘라", "라스", "스틱", "틱서", "서치", "치는", "는 ", " 강", "강력", "력한", "한 검", "검색", ...]

→ 검색어 "엘라스틱서치" → ["엘라", "라스", "스틱", "틱서", "서치"] 로  검색 시
"엘라스틱서치"라는 단어가 정확히 있는 문서와, 단지 비슷한 n-gram 조각이 있는 문서가 모두 검색됨!

- "스틱을 이용한 서치 기법" 이 검색 될 수 도 있다. → 왜? "스틱", "서치"라는 조각이 들어있기 때문!
  - 즉, 노이즈 문서가 검색 결과에 포함됨 → 정밀도↓

해결방법

정밀도를 높이기 위해 `필터링` 을 수행 할 수 있다.
검색된 결과를 하나하나 조회해서 검색어가 포함된 단어인지 아닌지 확인한다.

- ex)
  - 검색어: `"엘라스틱서치"`
  - 문서 본문: `"엘라스틱도 좋고, 서치 기술도 좋아."`

    → n-gram 조각은 일치할 수 있지만 본문 내 `"엘라스틱서치"` 라는 단어가 없으므로 **결과 제외**

- 단점
  - 후처리 비용 증가
    - 정확도는 높아지겠지만 검색 결과의 전문을 조사해야 하기 때문에
      결과가 커질 수록 검색시간이 증가한다.

### 재현률과 적합률

검색 엔진의 척도를 파악할 떄 쓰이는 단위를 의미한다.

- 재현율 : 올바른 결과를 반환했는가?
  - 올바른 결과의 수 / 반환한 결과 총 수
- 재현율 : 이것저것 망라해서 반환했는가?
  - 올바른 결과의 수 / 적합한 결과 총 수

## Postings 작성법

`Postings`란 해당 단어를 포함하는 문서 번호 또는 `ID`를 지니고 있는 배열이다.

![image.png](attachment:3f9f0e15-df97-44b5-99bc-bd606af890e5:image.png)

위에서는 단순하게 문서`ID`만을 보유하고 있는데,
크게 아래와 같은 방법들이 있다.

- term이 해당 문서 내의 어느 위치에 출현하는지 “출현 위치”를 같이 저장하는 방법
- 문서 ID만 저장하는 방법

### 문서 ID와 함께 term의 출현 위치를 같이 저장하는 방법

단어가 해당 문서 내의 어느 위치에 출현하는지 그 출현위치도 저장하는 경우도 있는데,
이것을 `Full Inverted Index`라고 한다.

- 장점
  - 스니핏을 뽑아낼때, 이 단어가 문장내의 어디에 포함되어 있는지 바로 알 수 있다.
  - 스코어링에 도움이 된다.
  - n-gram 이용 시 필터링에 도움이 된다.

### 문서 ID만 저장하는 방법

- 출현 위치를 저장하지 않으면 처음에 본 것처럼 단어에 대응하는 문서 `ID`가 나열된 배열에 불가하므로
  데이터 구조로써 단순하다.
- `VB Code`를 활용해 압축할 수 있다.
- 역 인덱스라는 것은 결국엔 `key-value` 구조이다.
  따라서 `key-value` 스토어에 저장하기 적합하다.