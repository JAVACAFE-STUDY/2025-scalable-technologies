# 9장 - 전문 검색기술 도전

대규모 데이터 처리의 노하우

### 왜 검색인가? 응용을 적용하기 쉬운 기술

검색엔진은 다양한 알고리즘을 활용하고 있어 흥미롭고 원리를 응용해서 적용하기 쉽기 때문에 학습할 가치가 높다. 

# 24강 - 전문 검색기술의 응용범위

## 하테나의 데이터로 검색엔진 만들기

이번 장은 먼저 하테나에서 실제로 운용하고 있는 검색엔진에 대한 개요부터 시작해서 검색엔진을 만들 때 중요한 요소 중 하나인 **역 인덱스**(inverted index)에 대해 설명한다. 역 인덱스는 **Dictionary**라는 부분과 **Postings**라는 부분, 이렇게 두 가지 기본요소로 구성되어 있다. 이번 장은 역 인덱스를 기반으로 검색엔진의 기본구조를 이해하는 것을 목표로 한다.

## 하테나 다이어리의 전문 검색 - 검색 서비스 이외에 검색 시스템 이용

하테나 다이어리를 대상으로 한 검색엔진이란, 하테나 키워드로 하테나 다이어리의 전문을 검색하는 시스템이다. 하테나 키워드에 포함된 단어만 검색할 수 있다. 8GB의 메모리로 모든 다이어리를 검색할 수 있다.

![특정 키워드가 포함된 블로그를 찾을 수 있다.](9%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%83%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%201d6431715117803bba31cd6e024007d1/image.png)

특정 키워드가 포함된 블로그를 찾을 수 있다.

### 전에는 RDB로 처리했다

전에는 이 기능을 RDB로 구현했다. 새로운 글이 작성되면 포함하고 있는 하테나 키워드를 모두 찾아서 연관관계를 맺어둔다. 레코드 수가 너무 많아지는 문제가 생겼다.

### 검색기술의 응용

검색엔진을 만들어서 문제를 해결했다. 사용자가 검색어를 입력하는 식의 검색이 아니라 사용자가 보고 있는 페이지의 키워드를 검색 시스템에 입력해서 결과를 얻는다. 해당 키워드를 포함하는 블로그의 목록을 **일자순**으로 보여주는 방식으로 구현했다.

## 하테나 북마크의 전문 검색 - 세세한 요구를 만족시키는 시스템

마이 북마크 검색 사례

북마크한 사이트만을 대상으로 한 전문 검색엔진이다.

![image.png](9%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%83%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%201d6431715117803bba31cd6e024007d1/image%201.png)

하테나에서 자체 제작했다. 

기능적인 특징은 검색결과에 본문의 일부를 표시하는 ‘스니펫’ 기능이 있다. 이를 구현하려면 검색어가 문서에서 어느 위치에 있는지 빠르게 알아내야 하기 때문에 데이터 구조가 약간 복잡해진다. 

사용자 별로 북마크한 사이트만 검색하면 된다고 해도 하나의 테이블에 모든 정보를 담는 식으로 구현하면 데이터가 커질수록 한계가 명확하다. 그래서 검색 시스템을 별도로 만들어서 사용자가 북마크를 추가하는 타이밍에 사용자별로 검색 인덱스를 준비해두고 이를 갱신한다. 검색할 때는 해당 사용자의 인덱스에서만 검색한다.

# 25강 - 검색 시스템의 아키텍처

## 검색 시스템이 완성되기까지

검색 시스템을 구현하려면 몇 가지 단계를 거쳐야한다.

1. 크롤링
2. 저장
3. 인덱싱
4. 검색
5. 스코어링
6. 결과표시

처음으로 검색할 대상 문서를 가져와야 한다. 대상 문서가 웹에 있다면 웹 크롤러를 만들어서 대량 문서를 가져온다. 다음으로 가져온 문서를 **저장**한다. 저장한 문서로 **인덱스**를 구축한다. 여기까지 하면 검색이 가능한데 추가로 검색 결과의 순위를 결정하는 **스코어링**이나 **스니펫** 등을 표시하는 기능이 더 필요할 수도 있다.

이번 강에서는 **인덱싱**과 **검색**에 초점을 맞춘다. 

## 다양한 검색엔진

다양한 오픈소스 검색 엔진이 있다. 

- grep
- `Apache Lucene(ES)`

## 전문 검색의 종류

전문 검색 아키텍처 종류는 다양하다. 여기서는

- grep형
- Suffix형
- 역 인덱스형

3가지를 소개한다.

### grep형

검색 대상 문서를 처음부터 끝까지 전부 읽는 가장 단순한 아키텍처다. 

검색 대상인 텍스트의 길이를 m, 검색하려는 검색어의 길이를 n이라고 하면 `O(mn)`의 시간복잡도를 가진다.

- 장점
    - **즉시성 :** 문서가 갱신되더라도 바로 검색할 수 있다. (인덱스 구축을 안 해도 돼서?)
    - **검색누락 X** : 문서를 전부 읽기 때문에 누락될 일이 없다.
    - **쉬운 병렬화** : 매우 긴 문서 검색 시 분할해서 병렬로 처리해도 되고, AC법과 같이 검색하고자 하는 단어를 하나의 오토마톤에 모으고 그 안에 문서를 집어넣으면 복수 검색어를 한 번에 검색할 수 있다.

### Suffix형

검색 대상 전문을 검색 가능한 형태로 가지고 있다. 데이터 구조로는 Trie나 Suffix Array, Suffix Tree등이 있다.

문서를 검색 가능한 형태로 가지고 있고 전부 메모리에 올릴 수 있는 형태다.

실제 이 아키텍처를 가진 엔진은 좀처럼 구현하기 어렵다.

### 역 인덱스형

검색 엔진에서 주류다. **단어(term)와 문서를 연관**짓는 방식이다. 역 인덱스 방식의 특징은 역 인덱스를 문서와는 별개로 만들어야 한다. 즉, 검색하기 전에 전처리를 통해 인덱스를 만들어야 한다.

- 단점
    - 즉시성은 grep에 비해 떨어진다.
    - 구현방법에 따라 검색누락이 생길 수 있다.
- 장점
    - 인덱스 압축 가능
    - 쉬운 대규모화
    - 적절한 구현 난이도
    - 좋은 밸런스

# 26강 - 검색엔진의 내부구조

## 역 인덱스의 구조 - Dictionary+Postrings

역 인덱스의 내부는 크게 Dictionary와 Postrings로 나눌 수 있다.

![image.png](9%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%83%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%201d6431715117803bba31cd6e024007d1/image%202.png)

1이 검색하고자 하는 대상 **문서**다. 각 문서는 번호가 달려있다.

2는 문서를 가지고 만든 **인덱스**다. 인덱스에서 왼쪽의 단어들이 **term**이다. 이 term 전체가 **Dictionary**다.

우측이 Postrings다. 각 term을 포함하는 문서를 나타낸다. ‘하테나’라는 term은 1,3,4번 문서에 포함되어 있다는 뜻이다. 이것이 역 인덱스다. term은 문서 내의 단어고 문서를 검색할 수 있는 단위다. 역 인덱스는 term을 포함하는 문서를 즉시 발견할 수 있는 구조다. 

## Dictionary 만드는 법 - 역 인덱스 작성법 #1

Dictionary를 만들 때는 term을 선택하는 다양한 방법이 있다. 

- 단어를 term으로
    - 미리 정해놓은 사전을 사용할 수도 있고 AC법과 같은 것으로 단어를 분리
    - 형태소 분석을 사용하는 방법
- **n-gram**을 term으로

### 언어의 단어를 term으로 하는 두 가지 방법

영어는 공백으로 구분하면 단어를 추출할 수 있다. 일본어의 경우 공백이 없고 단어의 분기점을 알 수 없기 때문에 사전 + AC법이나 형태소 분석을 사용한다.

### 1. 사전과 AC법을 이용하는 방법

사전이 곧 검색 시스템의 단어공간이 된다. 즉, 사전에 들어 있는 단어만 검색할 수 있다. 하테나 키워드의 ‘포함하는 블로그’ 기능은 하테나 키워드를 사전으로 하테나 다이어리의 모든 블로그 기사에서 단어를 추출해 Dicrionary로 사용한 시스템이다.

### 2. 형태소 분석을 이용하는 방법(형태소를 term으로 사용)

형태소 분석기의 핵심 기능은 ‘**유형파악과 분리**’다. 문장을 형태소로 나눠서 품사를 추정한다. 품사를 추정하는 방법은 대부분 내부에 사전을 가지고 있어서 단어별 품사가 정의되어 있다. 분석기 종류에 따라서 사전에 없는 단어도 기계학습을 통해서 예상할 수 있다. 

### 검색누락

다시 Dictionary로 돌아와, 형태소를 사용할 경우와 같이 단어를 term으로(Dictionary의 요소) 사용하면 ‘검색누락’이 발생할 수 있다.

예를 들어 구글에 “Gears 발매일”일 검색하면 “Gears of War”의 발매일이 나온다. 하지만 “Gear 발매일”을 검색하면 “Metal Gear”가 나오는 경우가 있었다. 

Gears라는 단어에는 Gear가 포함되어 있는데 사전에는 Gears만 있는 경우 Gear로는 Gears가 검색되지 않는다. 원형을 구할 수 있는 알고리즘이나 구현, 예를 들면 Stemming이나 Lemmatizer 등으로 해결할 수 있다.

### n-gram을 term으로 다루기

n-gram을 사용해서 Dictionary를 만드는 방법이 있다. 

n-gram은 글자를 n개 씩 잘라서 단위로 사용하는 방법이다. robot을 3-gram으로 나누면 rob, obo, bot로 나눌 수 있다. n-gram으로 잘라낸 단위를 Dictionary의 term으로 사용할 수 있다.

![“하테나의 마스코트인 시나몬은 도쿄에 없다”를 2-gram으로 분할해서 term으로 사용](9%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%83%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%201d6431715117803bba31cd6e024007d1/image%203.png)

“하테나의 마스코트인 시나몬은 도쿄에 없다”를 2-gram으로 분할해서 term으로 사용

### 쿼리도 동일한 규칙으로 분할하기

n-gram을 Dictionary로서 사용할 경우, 쿼리도 동일한 규칙으로 분할한다. “하테나”로 검색하는 경우 “하테”와 “테나”로 분할한다. 이 두 가지 쿼리로 역 인덱스를 조회하면 두 개의 Postrings가 얻어진다. 결과에 공통으로 포함된 문서번호가 “하테나”를 포함하는 문서다. 

### n-gram 분할 문제와 필터링

n-gram Dictionary는 검색어가 포함되지 않는 결과를 반환할 때가 있다. 예를 들면 2-gram Dictionary에서 “서울시”를 검색하면 “서울타워”가 포함된 문서가 검색된다. 해당 문서에는 “서울시”가 없기 때문에 잘못된 결과다. 이 문제를 회피하기 위해서 보통 검색 결과를 **필터링**한다. 실제로 문서에 해당 단어가 포함되었는지 확인한다. 문서가 커질 수록 필터링은 비효율적이다. 

하테나 북마크 검색에서는 단어를 기반으로 하는 역 인덱스와 n-gram을 기반으로 한 역 인덱스를 모두 사용한다. 타이틀, 코멘트, URL을 대상으로 검색할 때는 n-gram을 사용해서 검색누락을 피하고 문자열도 짧기 때문에 간단히 필터링할 수 있다. 본문 검색에는 단어 기반을 사용한다. 최근에는 이 두 인덱스에 쿼리를 날려서 결과를 병합하는 연구를 하고 있다. 

### 재현율(Recall)과 적합률(Precision)

검색누락 예시에서 Gear를 검색했을 때 Gears가 나오는 게 맞을까? 상황에 따라 다르겠지만 정량적인 평가를 내리는 기준이 있다. 바로 재현율과 적합률이다. 

![image.png](9%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%83%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%201d6431715117803bba31cd6e024007d1/image%204.png)

A는 검색결과, B는 검색 시스템에 있는 적합한 문서다. 예를 들어 “하테나”로 검색할 때 “하테나”를 포함하는 문서가 B다. C는 검색결과 중에서 올바른 문서다. (적합률 = C/A) (A에 올바른 결과가 얼마나 포함되어 있는지. 1에 가까울 수록 정확하다고 할 수 있다.)

재현율이 높다는 것은 검색결과에 포함된 정답이 전체 정답(B)과 가깝다는 뜻이다. 즉, “하테나”를 포함하는 문서 중 몇%나 찾았냐라는 뜻이다.

적합률이 높다는 것은 검색결과 중에 정답의 비중이 높다는 뜻이다. 

만약 “하테나”를 포함하는 문서가 100개가 있는데 검색 결과로 문서가 1건만 나왔고, 그 문서에 “하테나”가 포함되었다면 적합률은 1이고 재현율은 0.01이다. 즉, 결과는 정확하지만 정답의 1%밖에 맞추지 못한 것이다.

반대로 하테나가 포함된 문서 100개를 모두 찾았지만 검색결과가 500개라면 재현율은 1이고, 적합률은 0.2다. 

**검색결과 측면에서는 대상 문서가 많이 존재해도 그 중에 50건 정도만 적당하게 뽑아내서 그 중에서 꽝이 하나도 없는 것이 가장 좋은 경우다**. 적합률은 1에 가깝되 그 수가 너무 적지 않아야 한다. (재현율보다 적합률이 우선순위가 더 높다.)

### 검색 시스템 평가와 재현율/적합률

두 지표를 사용하면 검색 시스템의 성능을 정량화할 수 있다. 

형태소 분석과 n-gram을 보면 형태소 분석은 검색누락이 있을 수 있지만 의도하지 않은 결과가 나오는 경우는 적기 때문에 **적합률이 우선**시된다. 반면 n-gram은 검색누락은 발생하지 않지만 의도치않은 결과가 반환되는 경우가 있기 때문에 재현율이 우선시된다. (필터링이 필요한 이유)

## 지금까지 내용 정리

검색엔진은 grep형, Suffix형, 역 인덱스형이 있다. 

주류는 역 인덱스형. 

Dictionary + Postrings 구조. Dictionary를 구성하는 다양한 방법이 존재.

## Postrings 작성법 - 역 인덱스 작성법 #2

![image.png](9%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%83%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%201d6431715117803bba31cd6e024007d1/image%205.png)

Postrings는 해당 단어를 포함하는 문서 번호 또는 ID를 지닌 배열이라고 생각하면 된다.

예시는 ID만 저장하지만 해당 문서에서 term의 위치를 저장하기도 한다. 이를 Full Inverted Index라고 한다. 출현위치를 가지고 있으면 스니펫을 뽑아낼 때 유용하다. 

스코어링에도 도움이 된다. “하테나”와 “교토”로 and 검색 시 단어 사이의 근접도로 스코어링 할 때 단어 출현위치를 사용한다. 

n-gram을 이용해서 필터링할 때도 두 단어의 위치가 너무 멀다면 제외시킬 수 있다.

### 출현위치를 저장하지 않고 문서 ID만을 저장하는 타입

Inverted File Index라고 하는 경우가 있다. 문서 ID가 저장된 배열에 불과하기 때문에 VB Code로 압축할 수 있다. key-value 스토어에 적합하다. 

처음 설명한 다양한 검색엔진은 역 인덱스를 저장하기 위한 key-value 스토어를 지니고 있는 경우가 많다. 

## 스코어링에 대한 보충

스코어링을 구현하는 방법은 매우 다양하다. 특정 단어가 문서내에서 중요도가 높다고 판단되면 이 문서의 순위를 높이는 일도 가능하다. 이럴 때는 TF/IDF를 이용해도 좋다. 

많은 검색어가 주어졌을 때 문서에 포함되어 있는 단어의 열을 보고 문장과 주어진 단어열이 비슷한지 예측하는 방법도 있다.