# 4장 - 분산을 고려한 MySQL 운용

DB 스케일아웃 전략에 대해 자세히 살펴보자. 

# 11강 - 인덱스를 올바르게 운용하기

> 분산을 고려한 MySQL 운용의 대전제
> 

## 분산을 고려한 MySQL 운용, 세 가지 포인트

1. OS 캐시 활용 (3장에서 다뤘다.)
2. 인덱스
3. 확장을 전제로 시스템을 설계

## OS 캐시 활용

레코드가 많아질 수록 스키마 변경의 영향이 크다. 3억 레코드가 있는 테이블에 8바이트에 컬럼을 하나 추가하면 3GB의 저장공간이 더 필요해진다.

대량의 데이터를 저장하려는 테이블은 레코드가 가능한 작아지도록 설계해야 한다. 정수 int형은 4바이트, 문자열(UTF-8 한글 한 글자는 3바이트다.)은 1바이트와 같은 기본적인 수치를 기억해둔다. 

### [보충] 정규화

![image.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A9%E1%84%85%E1%85%A7%E1%84%92%E1%85%A1%E1%86%AB%20MySQL%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%AD%E1%86%BC%201c543171511780179db2ccc59e5d9896/image.png)

is_private, is_asin 컬럼은 선택적으로 사용되기 때문에 별도의 테이블로 분리할 수 있다. 이렇게 되면 bookmark 테이블의 용량을 줄일 수 있다. 이런식으로 별도의 테이블로 분리하는 경우 쿼리가 복잡해져서 속도가 떨어지는 경우가 있기 때문에 속도와 데이터 크기의 트레이드 오프를 잘 판단해서 분리한다. 

## 인덱스의 중요성 - B트리

알고리즘, 데이터 구조에서 탐색할 때는 기본적으로 트리(탐색트리)가 널리 사용된다. 인덱스는 주로 탐색을 빠르게 하기 위한 것으로, 트리로 구현한다.

![image.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A9%E1%84%85%E1%85%A7%E1%84%92%E1%85%A1%E1%86%AB%20MySQL%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%AD%E1%86%BC%201c543171511780179db2ccc59e5d9896/image%201.png)

MySQL의 인덱스는 기본적으로 B+트리를 사용한다. B+트리는 B트리의 파생 트리다. B트리는 트리를 구성하는 각 노드가 여러 개의 자식을 가질 수 있는 ‘**다분 트리**’다. 데이터 삽입, 삭제를 반복해도 트리의 균형이 유지되는 ‘**평형 트리**’이기도 하다. B트리는 하드디스크 상에 구축하기 알맞은 데이터 구조여서 DB에서 자주 사용된다. 

B트리는 정렬되어 있기 때문에 찾고자하는 데이터를 루트에서부터 비교하면서 찾아내려가기 때문에 `O(log n)`으로 검색할 수 있다. 

### 이분트리와 B트리 비교해보기

![image.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A9%E1%84%85%E1%85%A7%E1%84%92%E1%85%A1%E1%86%AB%20MySQL%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%AD%E1%86%BC%201c543171511780179db2ccc59e5d9896/image%202.png)

이진트리는 자식노드가 반드시 2개 이하다. 반면 B트리는 m에 따라 자식 노드의 수가 결정된다. B트리는 이 수를 조절함으로써 노드의 크기를 4KB 등으로 조절할 수 있다. 

노드의 크기는 3장에서 살펴본 디스크의 페이지와 밀접하다. 노드 1개로 디스크의 1블록만큼 할당하면 B트리로 디스크상에 저장했을 때 각 노드를 딱 한 블록만큼으로 저장할 수 있다.

이렇게하면 노드를 찾아갈 새로운 노드를 찾아갈 때만 디스크를 읽으면 된다. 노드 내의 데이터는 메모리에서 빠르게 탐색할 수 있다. 

반면 이진트리는 이런 최적화가 어렵기 때문에 I/O가 많아져서 비효율적이다.

![image.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A9%E1%84%85%E1%85%A7%E1%84%92%E1%85%A1%E1%86%AB%20MySQL%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%AD%E1%86%BC%201c543171511780179db2ccc59e5d9896/image%203.png)

B+트리는 리프노드끼리 연결되어 있기 때문에 범위검색에 효율적이다. 데이터는 리프노드에만 있고 internal 노드에는 키만 가지고 있어서 메모리 사용이 효율적이다.

## 인덱스의 효과

데이터가 10억 건인 경우 약 30번의 연산으로 원하는 결과를 얻을 수 있다. `O(log n)`

계산량 뿐 아니라 I/O에서도 상당한 이점이 있다.

### [보충] 인덱스의 작용 - MySQL의 특성

MySQL에서는 인덱스를 걸어놓고 있는 컬럼을 대상으로 한 쿼리라도 SQL에 따라 인덱스가 사용되기도, 그렇지 않기도 하다. 기본적으로 `where, order by, group by`의 조건에 지정된 컬럼은 인덱스가 사용된다. 또한 쿼리에 사용할 인덱스를 명시할 수 있다.

PK, UNIQUE 제약이 걸린 컬럼은 인덱스를 가지고 있다. 

A, B 컬럼에 각각 인덱스를 생성해두고 `where A order by B`하면 하나의 인덱스만 사용된다. A,B 모두 인덱스를 태우려면 (A, B) 복합 인덱스를 생성해야 한다.

## 인덱스가 작용하는지 확인하는 법 - explain 명령

explain 명령으로 해당 쿼리의 실행계획을 알 수 있다.

![image.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A9%E1%84%85%E1%85%A7%E1%84%92%E1%85%A1%E1%86%AB%20MySQL%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%AD%E1%86%BC%201c543171511780179db2ccc59e5d9896/image%204.png)

첫번째 쿼리는 인데스를 타고 있다. 결과가 1개라는 것을 알 수 있다. 

두번째 쿼리는 일부러 다른 인덱스를 사용하게 해서 유효한 인덱스를 타지 못하게 했다. 9백만개의 레코드를 다 살펴봐야 한다.

- Extra의 내용도 중요하다. Using filesort나 Using temporary같은 항목이 보이는 것은 그다지 좋은 상황은 아니다. 각각 레코드 정렬에 외부 정렬(외부 파일을 사용한 정렬)이나 임시 테이블이 필요하기 때문이다.
- 슬로우 쿼리 모니터링을 잘하자..!

# 12강 MySQL의 분산

> 확장을 전제로 한 시스템 설계
> 

## MySQL의 레플리케이션 기능

어떻게 MySQL을 분산할 것인가??

![image.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A9%E1%84%85%E1%85%A7%E1%84%92%E1%85%A1%E1%86%AB%20MySQL%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%AD%E1%86%BC%201c543171511780179db2ccc59e5d9896/image%205.png)

MySQL에는 기본 기능으로 레플리케이션 기능이 있다. 

레플리케이션이란 마스터(Primary)를 정하고 마스터를 따르는 슬레이브(secondary)를 정해두면 마스터에 쓴 내용을 슬레이브가 폴링해서 동일한 내용으로 자신을 갱신하는 기능이다. 슬레이브는 마스터의 레플리카가 된다. 이렇게 동일한 내용의 서버를 여러 대 마련할 수 있다. 

ap 서버에서 로드밸런서를 경유해서 여러 대의 secondary 서버에 쿼리(질의 SQL)를 분산할 수 있다. 커맨드(갱신 SQL)는 primary서버로 요청하고 쿼리는 secondary로 요청한다. 커맨드를 secondary로 보내면 MySQL은 두 서버의 불일치를 감지해서 레플리케이션을 중단한다.

## 마스터/슬레이브의 특징 - 참조계열은 확장하고 갱신계열은 확장하지 않는다.

이 구성은 쿼리는 secondary 서버를 늘려서 분산하면 되지만 커맨드는 분산할 수 없다. 또 primary의 다중화 문제도 있다. 대부분의 웹 애플리케이션에서는 쿼리가 90%이상이다. 따라서 primary가 병목이 되어 곤란한 상황이 발생하는 경우는 그렇게 많지 않다. (애플리케이션에 따라 다를듯… 디스코드 같은 경우..??)

### 갱신/쓰기계열을 확장하고자 할 때 - 테이블 분할, key-value 스토어

드물지만 primary에 엄청난 쓰기작업이 발생하는 애플리케이션을 개발하는 경우가 있다. 이런 경우에도 테이블을 분할해서 테이블 크기를 작게 한다. 그러면 분할로 인해 쓰기작업이 분산된다. 테이블 파일이 분산되면 동일 호스트 내에서 여러 디스크를 가지고 분산시킬 수도 있으며, 서로 다른 서버로 분산할 수도 있다. 

아니면 처음부터 RDBMS를 사용하지 않는 방법도 있다. 하테나에서는 우고메모의 동영상 재생횟수를 표시하는 부분에서 사용자가 동영상을 재생할 때마다 갱신이 일어나기 때문에 쓰기작업이 너무 많다. 이런 경우 RDB를 사용하지 않고 key-value 스토어를 사용한다. 단순히 값을 저장하고 꺼낼 뿐이므로 RBD가 갖는 복잡한 통계처리나 범용적인 정렬처리가 필요하지 않기 때문에 오버헤드가 적고 압도적으로 빠르고 확장하기 쉽다. 

애플리케이션 측면에서 연구해서 처음부터 쓰기작업 횟수를 줄여야한다.

# 13강 MySQL의 스케일아웃과 파티셔닝

## MySQL의 스케일아웃 전략

MySQL의 기본적인 스케일아웃 전략은 데이터가 메모리에 올라가는 크기면 메모리에 올리고, 올라가지 않으면 메모리를 증설하는 것이다. 그리고 인덱스를 제대로 걸어야 한다. ‘메모리 증설이 불가능하면 파티셔닝’을 좀 더 살펴보자.

## 파티셔닝(테이블 분할)에 관한 보충

![image.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A9%E1%84%85%E1%85%A7%E1%84%92%E1%85%A1%E1%86%AB%20MySQL%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%AD%E1%86%BC%201c543171511780179db2ccc59e5d9896/image%206.png)

파티셔닝(테이블 분할)이란 테이블A와 테이블B를 서로 다른 서버에 놓아서 분산하는 방법이다. 

## 파티셔닝을 전제로 한 설계

파티셔닝에 관한 것 중 잊어서는 안 될 것이 **파티셔닝을 전제로 한 설계**다.

![image.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A9%E1%84%85%E1%85%A7%E1%84%92%E1%85%A1%E1%86%AB%20MySQL%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%AD%E1%86%BC%201c543171511780179db2ccc59e5d9896/image%207.png)

하테나 북마크의 테이블은 entry와 tag가 나뉘어 있다. 가끔 이 두 테이블을 함께 사용할 경우가 있다. 예를 들면 어떤 태그를 포함하는 엔트리 목록을 뽑는 경우, 두 테이블을 JOIN해야 하는데 두 테이블은 다른 서버에 있기 때문에 JOIN할 수 없다. (5.1부터 FEDERATED를 사용하면 가능)

![image.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A9%E1%84%85%E1%85%A7%E1%84%92%E1%85%A1%E1%86%AB%20MySQL%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%AD%E1%86%BC%201c543171511780179db2ccc59e5d9896/image%208.png)

JOIN을 사용하지 않고 tag테이블에서 ‘perl’ 태그를 포함하는 앤트리의 eid를 조회해서 이 eid를 가지고 엔트리 테이블에서 조회하는 식으로 쿼리를 둘로 나누면 결과를 얻을 수 있다. 따라서 기본적으로는 JOIN쿼리는 대상이 되는 테이블을 앞으로도 서버 분할하지 않을 것이라고 보장할 수 있을 때만 사용한다.

**entry와 bookmark는 상당히 긴밀하게 결합하고 있기 때문에 같은 서버에 두고 JOIN해서 사용한다. 하지만 tag와 entry 테이블은 그다지 밀접하게 결합하지 않고 데이터 크기를 볼 때 반드시 분할해야 하기 때문에 JOIN하지 않는 방침을 취하고 있다**. 

## JOIN 배제 - where … in … 이용

![image.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A9%E1%84%85%E1%85%A7%E1%84%92%E1%85%A1%E1%86%AB%20MySQL%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%AD%E1%86%BC%201c543171511780179db2ccc59e5d9896/image%209.png)

4.10은 entry와 bookmark를 INNER JOIN하는 쿼리다.

![image.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A9%E1%84%85%E1%85%A7%E1%84%92%E1%85%A1%E1%86%AB%20MySQL%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%AD%E1%86%BC%201c543171511780179db2ccc59e5d9896/image%2010.png)

4.11은 같은 결과지만 먼저 bookmark에서 eid를 조회하고, 조회한 eid로 entry를 조회하는 식으로 쿼리를 2개로 나눈 모습이다. 

하테나에서는 O/R 매퍼를 직접 개발해서 두 개의 테이블에 걸친 API를 호출하는 경우 JOIN을 사용하지 않고 where … in … 생성하고 있다.

## 파티셔닝의 상반관계

파티셔닝에는 상반관계(트레이드 오프)가 존재한다. 좋은 점은 부하가 내려가고 국소성이 늘어나서 캐시 효과가 높아진다. 단점은 다음과 같다.

### 운용이 복잡해진다

서버마다 데이터가 다르기 때문에 어디에 어떤 데이터가 있는지 파악하기 힘들다.

### 고장률이 높아진다

대수가 늘어나는 만큼 고장확률이 높아지는 문제가 있다.

내장애성을 생각할 때 분할과 동반해서 머신을 늘릴 때는 1대만 늘려서는 안된다. 

![image.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A9%E1%84%85%E1%85%A7%E1%84%92%E1%85%A1%E1%86%AB%20MySQL%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%AD%E1%86%BC%201c543171511780179db2ccc59e5d9896/image%2011.png)

A라는 호스트(DB)가 있고 이를 분할해서 A1과 A2로 나누는 경우 단순히 2대가 되는 게 아니라 A는 원래 4대 였고 이를 분할하면 8대가 된다. 

### 다중화에 필요한 서버 대수는 몇 대?

![image.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%A9%E1%84%85%E1%85%A7%E1%84%92%E1%85%A1%E1%86%AB%20MySQL%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%AD%E1%86%BC%201c543171511780179db2ccc59e5d9896/image%2012.png)

다중화를 하면 서버는 4대가 기본이다. 이유는 장애 상황을 살펴보면 된다. 서버가 3대(primary 1, secondary 2)일 경우 secondary 한 대가 죽었다고 하자. 나머지 secondary가 살아있기 때문에 문제가 없을 것 같지만 새로운 secondary를 편입하려면 현재 동작하는 secondary를 중지하고 데이터를 복사해야 한다. 이러면 서비스가 중단된다. 그렇기 때문에 복구용으로 한 대를 더 갖춰야한다. (진짠가?)

### 애플리케이션의 용도와 서버 대수

애플리케이션의 기능에 따라 무정지가 필수가 아니라면 기능을 멈추고 유지보수할 수 있기 때문에 모든 DB가 꼭 4대씩 필요하다고 할 수는 없다. 무정지가 필수라면 더 안정적으로 구성해야할 수도 있다.

### 서버 대수와 고장률

분할하면 대수가 늘어나고 관리에 필요한 리소스도 많아지기 때문에 많이 분할한다고 좋기만 한 건 아니다. 스케일업과 비교해서 더 효율적인 방법을 선택한다.